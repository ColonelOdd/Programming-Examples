## Preface
When I first began this project, I had expected that my 'Good' goal would be comparable in labor to the finance website. The project I knew was going to make similar use of a SQL database in a comparable way and adjust it based on users inputs, albeit with linking it to images and ultimately using the information provided to make a game within HTML. I knew there would be plenty of details to parse out, but I thought I had a place to start off from in finance that I could expand upon to make my own for my own reasons. It would give me plenty of time to work on the 'Great' and beyond goals I had laid out, since the base project was plenty reasonable in my mind.

I turned out to be dead wrong. First off, while finance was a helpful reference for aspects of the SQL database, the parts that I knew were going to be difficult turned out to be very different from SQL and required hours and hours of experimentation to get working as intended. I had been told the Hackathon would help me complete around 70% of my project by former CS50 students, but, in my case, even staying up the whole time really only got me done with about a third of my project. It was very frustrating experience, though something I had been warned about numerous times throughout the project: development is often slower than one expects, especially when you have other obligations.

That being said, I am ultimately somewhat happy with the final product, even though it took a long time for less than I was expecting it to take.

## Design Philosophy
From the get go, I knew this project would revolve around the SQL databases. My plan from the outset was to link the images names with SQL, then use Jinja to link the information about my images with a program keeping track of every "frame" of the game. That way, I could keep all the dialogue, poses, characters, and positions in a single database that would ultimately translate into the graphics the user would see on the "play" part of the website. Throughout the project, that mentality never centrally changed. Every part of my program is designed to let the SQL database do its work when everything is in place.  As a result, I made sure to name and sort most of the files I wanted to call in specific ways; for instance, all the characters are sorted into a specific folder and divided into specific subfolders with the position those characters are located in.

Phoenix, the main defense attorney of the series, had all of his poses sorted under "static/images/characters/defense/Phoenix/".  This was all done so that I could pass the elements from my database, such as position being "defense" and the name of the character "Phoenix" being information I could use in the retrieval in the sorting of images. Basically every element linked to the databases was organized in similar ways to make their retrieval "easy" when I eventually got there.  Though not a perfect system, it did allow me to translate a lot of information to HTML from databases that would be difficult to do otherwise.

## Design Implementation
I'll be going through by parts to discuss the major hurdles of my design, organized by the major sections of code.
# Quick Note
I also want to mention here that despite using a fairly limited number of characters on CaseMaker, any character with the same role could be implemented so long as the dimension of their sprites are the same as other characters. (In the place I found the sprites online, this was the case, so its completely doable.)  The reason I didn't do this was primarily worries about how many high quality GIFs I should store on here, partially because of how many witnesses there are compared to the other roles (Phoenix is the protagonist of the first 3 games and there is an art style shift to the fourth game), and consideration for how much datbase inputting I would have to do. The code for witnesses is not written differently for defense, judge, or prosecutor; if there were multiple prosecutors, judges, defense attorneys, the code would work the exact same way for them as for witnesses.
# SQL
User ids were stored similarly to in finance, and were linked with the games table to link game ids to user_ids to keep track of which games to print for each user at various fields. The central two databases beyond that were frames and characters.  Characters essentially contained all of the information I didn't need in frames, but needed for keeping track of all the information kept in my images folder. It contained information about each character, their position, and each one of their poses. I had to use it to keep track of the editing side of things before data is submitted to frames:

The full frames SQL database linked together game id, frame number, position, character, pose, and dialogue.  This essentially contained all the information I needed for the visuals, which allowed me to design everything else around this database. Therefore, a lot of folders of images and classes in the final play were named around the database, as to make it as easy as possible for me to retrieve the information when I got to the selection part.
# Login, Register, Create, Pick A Game, Index
The reason why I am lumping together these sections is because most of the implementation for these was either not largely coding based (i.e. Index was just made to look relatively nice in HTML) while the others were elements that were similar in implementation and strategy to finance or just not entirely difficult.  Login and Register work exactly the same as finance; my site was not in need of anything beyond a simple login.

Create was simply a way to let the user implement their game names to edit later on, which basically involved them inserting a game name into a SQL database keeping track of all the games, their names, and their respective users. Other than that, it felt relatively simple.

Pick A Game was just a simple helper page I designed so that the user could pick which game they were editing it. The only part worth noting is that I actually used this form for both picking a game to play and edit, since they served the exact same purpose.  I just passed in through Jinja where I wanted to redirect the user after they had submitted the form and it worked.

This section isn't made to deemphasize these parts from the design process, but the two pages where I spent 90% of my time on were Play and Edit, so I'm focusing on those primarily since they are where the most of the design process and thought was spent
# Edit
Edit was the function I had by far underestimated the most in terms of effort. The basic idea was fairly simple: I wanted the user to be able to add and adjust all the frames of the games in one place and then submit them all to be uploaded to the database.  Of course, whenever someone edited a game, all their pre-existing progress should be carried over and readjusted.

To do this, I had to insert all the information from the frames via Jinja that was stored about the games in Frames. What I had not realized is that I couldn't simply dump the information onto a table on the webpage; since all this information had to be adjustable, all the information about the frames had to be in forms that people could edit and be just one of other options. I also realized that all these options had to adjust dynamically; Phoenix had different poses from the witness Gumshoe, so only his poses should be able to be picked as options when he is selected as the character.  And of course, since Phoenix is in the position defense and not witness, he should not be an option for characters if the position is set to witnesses.  What this meant was that I had to have functions checking each of these fields to dynamically adjust the other inputs of the row if there was a change.

Before doing this assignment, I didn't have very much experience with JavaScript.  I made very basic use of it in homepage and very little in finance, but for this project I realized I would have to learn to make my peace with it if I were to get any of it working. Through Jinja, I was able to pass in some of the information I needed into each field, but I would need a JavaScript function to add everything I needed at the beginning.  To start, I passed in helper lists of the SQL database to help me parse some things out; one for each of the main positions (defense, prosecution, judge, witness) containing each of their members, and one for all of the distinct poses, each linked to a character name. Since I knew what specific position/character/poses was being inputted, I needed Javascript to find the other members of the position (which isn't information passed in from frames), as well as all of the possible poses of the character selected.

Thus, I effectively had a JavaScript function reverse engineer the database by some clever naming conventions. I name a constant list in JavaScript containing the name of each helper list, which allowed me to use Jinja to search through the list of the corresponding frame.  For instance, if I knew a frame's position was defense ({{ frame.position }} == defense), I could input that into JavaScript to make it call the corresponding list.  Therefore, it would go through the list of the members of a position and add those as options to the selector, and select the option that equal was the frame's character. Thus, the characters elected would always been in the same order regardless of who was selected. I applied very similar logic to find the poses corresponding to a character, by taking the character's name and adding poses as options who had the character's name in the same item.

Beyond that, I had to dynamically adjust frames when someone made changes to them after the page had loaded.  I did this by using careful naming conventions with ids and "onchange", which is an attribute that calls a JavaScript functions whenever someone selects an option in a form. Since adjusting position would influence multiple different fields, I needed a way to adjust other elements of the row with only the information passed in from a single row.  Thus, I resorted to having specific naming conventions for the "ids" of the elements of my table; depending on the row you were in, your id would always be the purpose of the field (for example, "position" for the selector where you pick positions) with a dash and the frame number you're on.  That way, I could take the last letter of an id of any field and make adjustments to the other fields of the row if necessary.  Once I had figured that out, it was fairly similar to the solution to the first check with Jinja, except on any of the rows.

Adding rows wasn't too complicated since I could get the number of rows of the body to determine frame number and then add the row at the bottom with the additional info I needed.  Submitting all the information required thorough checking; since I was inserting basically whole rows of data into frames, I had to cross check a lot for malicious input from the user that could screw up the database. JavaScript was more intensive than I had hoped, but at the end of it I came out with it working as expected.

# Play
One of the most frustrating aspects of the entire project was how ridicolously infuriating it was to stack images on top of each other. Not only was it difficult enough to figure out how to do in the first place, but lots of tiny adjustments head to be made constantly to get it all working. The sprites of the game series were stored partially in a way that worked to my advantage; all of the sprites of an individual character were always the exact same size (any pose of Phoenix always was the same sized gif) and all characters of the same type always had the same sized images as well (for instance, the witnesses Dahlia and Gumshoe have the same dimension sprites because of both being witnesses). This meant I only had to adjust every character based on their role and that any sprites of additional characters should be the same size as their respective roles (from the resource I got them from, at least).

Unfortunately, this meant that I had to adjust positions and sizes of objects when they transitioned to the next frame; witness sprites would have to be moved to a different position from defense sprites.  Related objects, like the witness stand, defense and prosecutor's benches, textbox, and more had to be adjusted every time the user clicked to the next frame in a way which the program could account for them.  My solution to this was initially putting as much as that information into classes as I could, since it would be convenient if I could just assign a "defense" class to defense sprites and make all the adjustments in position and size I neededed that way.  This was also done so I could easier link that information to the database, since keeping information about "style" or "size" in the database felt like it defeated the point of it.

In terms of how I ultimately linked the database for Jinja, I inserted functions into the <script></script> element of my header for every frame in frames (with the matching game_id of the game the user wants to play), each named "proceed" with the number of the frame after them.  Each program adjusts all the classes, positions, and images sources with information from the SQL frames database, then replaces the "onchange" attribute of the button used to proceed to the next frame of the game to the next function, thus creating a loop until the user has gone through all the frames. This solution made full use of the database and all of its benefits, making a way for the user's game to proceed efficiently.
